<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>KubeVirt VMI Serial Console</title>
	<link rel="stylesheet" href="assets/xterm.min.css">
	<style>
		html,
		body {
			height: 100%;
			margin: 0;
			background: #1b1b1b;
			color: #f5f5f5;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
		}

		body {
			display: flex;
			flex-direction: column;
		}

		.controls {
			display: flex;
			align-items: center;
			gap: 0.75rem;
			padding: 0.75rem 1rem;
			background: #111;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
			z-index: 1;
			flex-wrap: wrap;
		}

		.controls form {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			margin: 0;
			flex-wrap: wrap;
		}

		.controls input {
			padding: 0.35rem 0.6rem;
			border-radius: 4px;
			border: 1px solid #2f2f2f;
			background: #1f1f1f;
			color: #f5f5f5;
		}

		.controls button {
			padding: 0.35rem 0.9rem;
			border-radius: 4px;
			border: none;
			background: #0078d4;
			color: #fff;
			cursor: pointer;
		}

		.controls button:hover {
			background: #1f90f6;
		}

		#status {
			font-size: 0.9rem;
			color: #c0c0c0;
			min-width: 8rem;
		}

		#status.status-success {
			color: #4caf50;
		}

		#status.status-error {
			color: #ff6b6b;
		}

		#alert-banner {
			font-size: 0.9rem;
			color: #ff6b6b;
			background: rgba(255, 107, 107, 0.15);
			border: 1px solid rgba(255, 107, 107, 0.4);
			padding: 0.35rem 0.6rem;
			border-radius: 4px;
			display: none;
			max-width: 100%;
		}

		#alert-banner.visible {
			display: inline-flex;
			align-items: center;
		}

		#terminal {
			flex: 1;
			padding: 0.5rem;
		}
	</style>
</head>

<body>
	<div class="controls">
		<form id="connect-form">
			<label for="namespace">Namespace</label>
			<input id="namespace" name="namespace" type="text" placeholder="Namespace">
			<label for="vmi">VMI</label>
			<input id="vmi" name="vmi" type="text" placeholder="Virtual Machine Instance" required>
			<button type="submit">Connect</button>
		</form>
		<span id="status"></span>
		<span id="alert-banner" role="alert"></span>
	</div>
	<div id="terminal"></div>
	<script src="assets/xterm.min.js"></script>
	<script src="assets/xterm-addon-fit.min.js"></script>
	<script>
		(function () {
			const terminalContainer = document.getElementById('terminal');
			const statusEl = document.getElementById('status');
			const alertBanner = document.getElementById('alert-banner');
			const namespaceInput = document.getElementById('namespace');
			const vmiInput = document.getElementById('vmi');
			const form = document.getElementById('connect-form');
			const term = new Terminal({
				convertEol: true,
				cursorBlink: true,
				disableStdin: false,
				fontFamily: 'Menlo, Consolas, "Liberation Mono", monospace',
				theme: {
					background: '#1b1b1b'
				}
			});
			const fitAddon = new FitAddon.FitAddon();
			term.loadAddon(fitAddon);
			term.open(terminalContainer);
			fitAddon.fit();
			term.focus();

			let ws = null;
			const decoder = new TextDecoder();
			const params = new URLSearchParams(window.location.search);
			const initialNamespace = params.get('namespace') || '';
			const initialVMI = params.get('vmi') || '';
			if (initialNamespace) {
				namespaceInput.value = initialNamespace;
			}
			if (initialVMI) {
				vmiInput.value = initialVMI;
			}
			namespaceInput.addEventListener('input', syncQueryFromInputs);
			vmiInput.addEventListener('input', syncQueryFromInputs);
			syncQueryFromInputs();

			function updateStatus(text, level, detail) {
				statusEl.textContent = text || '';
				statusEl.classList.remove('status-success', 'status-error');
				if (level === 'success') {
					statusEl.classList.add('status-success');
				} else if (level === 'error') {
					statusEl.classList.add('status-error');
				}
				const detailText = level === 'error' ? (detail ?? text) : '';
				if (level === 'error' && detailText) {
					alertBanner.textContent = detailText;
					alertBanner.classList.add('visible');
				} else if (level !== 'error') {
					alertBanner.textContent = '';
					alertBanner.classList.remove('visible');
				}
			}

			function updateQuery(namespace, vmi) {
				const params = new URLSearchParams();
				if (namespace) {
					params.set('namespace', namespace);
				}
				if (vmi) {
					params.set('vmi', vmi);
				}
				const next = params.toString();
				const nextUrl = `${window.location.pathname}${next ? `?${next}` : ''}`;
				if (nextUrl !== window.location.pathname + window.location.search) {
					history.replaceState(null, '', nextUrl);
				}
			}

			function syncQueryFromInputs() {
				updateQuery(namespaceInput.value.trim(), vmiInput.value.trim());
			}

			function closeSocket() {
				if (ws) {
					ws.onopen = null;
					ws.onclose = null;
					ws.onerror = null;
					ws.onmessage = null;
					try {
						ws.close();
					} catch (err) {
						console.warn('error closing websocket', err);
					}
					ws = null;
				}
			}

			function connect(namespace, vmi) {
				closeSocket();
				const loc = window.location;
				const protocol = loc.protocol === 'https:' ? 'wss' : 'ws';
				const wsParams = new URLSearchParams();
				if (namespace) {
					wsParams.set('namespace', namespace);
				}
				wsParams.set('vmi', vmi);
				const endpoint = `${protocol}://${loc.host}/ws?${wsParams.toString()}`;
				const nsLabel = namespace ? namespace : '(default namespace)';
				updateQuery(namespace, vmi);
				console.log('connecting to websocket', endpoint);
				updateStatus(`Connecting to ${nsLabel}/${vmi} ...`);
				ws = new WebSocket(endpoint);
				ws.binaryType = 'arraybuffer';

			ws.onopen = function () {
				console.log('websocket open');
				term.clear();
				fitAddon.fit();
				updateStatus('Connected', 'success');
				term.focus();
			};

			ws.onmessage = function (event) {
				if (event.data instanceof ArrayBuffer) {
					term.write(decoder.decode(event.data));
				} else if (typeof event.data === 'string') {
					if (event.data === 'serial console ready') {
						updateStatus('Connected', 'success');
					} else if (event.data.startsWith('serial console error:') || event.data.startsWith('console ')) {
						updateStatus('Console error', 'error', event.data);
						term.writeln(`\r\n${event.data}\r\n`);
					} else {
						term.write(event.data);
					}
				}
			};

			ws.onerror = function (event) {
				console.error('websocket error', event);
				updateStatus('Connection error', 'error');
			};

			ws.onclose = function (event) {
				console.log('websocket closed', event);
				const statusText = event.wasClean ? 'Connection closed' : 'Connection lost';
				updateStatus(statusText, event.wasClean ? undefined : 'error');
			};
			}

			form.addEventListener('submit', function (event) {
				event.preventDefault();
				const ns = namespaceInput.value.trim();
				const vmi = vmiInput.value.trim();
				if (!vmi) {
					updateStatus('VMI is required', 'error');
					return;
				}
				connect(ns, vmi);
			});

			term.onData(function (data) {
				if (ws && ws.readyState === WebSocket.OPEN) {
					ws.send(data);
				}
			});

			window.addEventListener('resize', function () {
				fitAddon.fit();
			});

			if (initialVMI) {
				if (!initialNamespace && !namespaceInput.value) {
					updateStatus('Using kubeconfig namespace');
				}
				console.log('auto-connecting using URL parameters');
				updateStatus('Preparing connection ...');
				connect(initialNamespace || namespaceInput.value, initialVMI);
			}
		}
	)();
	</script>
</body>

</html>
