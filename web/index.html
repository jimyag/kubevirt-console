<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>KubeVirt VMI Serial Console</title>
	<link rel="stylesheet" href="assets/xterm.min.css">
	<style>
		html,
		body {
			height: 100%;
			margin: 0;
			background: #1b1b1b;
			color: #f5f5f5;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
		}

		body {
			display: flex;
			flex-direction: column;
		}

		.controls {
			display: flex;
			align-items: center;
			gap: 0.75rem;
			padding: 0.75rem 1rem;
			background: #111;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
			z-index: 1;
			flex-wrap: wrap;
		}

		.controls form {
			display: flex;
			flex-wrap: wrap;
			gap: 1rem;
			align-items: flex-end;
			margin: 0;
			flex: 1;
		}

		.field {
			display: flex;
			flex-direction: column;
			gap: 0.35rem;
		}

		.field-label {
			font-size: 0.85rem;
			color: #ddd;
		}

		.field-row {
			display: flex;
			gap: 0.5rem;
			align-items: center;
		}

		.field-row input,
		.field-row select {
			padding: 0.35rem 0.6rem;
			border-radius: 4px;
			border: 1px solid #2f2f2f;
			background: #1f1f1f;
			color: #f5f5f5;
			min-height: 36px;
			width: 220px;
		}

		.field-row select {
			min-width: 260px;
		}

		.controls button {
			padding: 0.45rem 1.2rem;
			border-radius: 4px;
			border: none;
			background: #0078d4;
			color: #fff;
			cursor: pointer;
			min-height: 36px;
		}

		.controls button:not(:disabled):hover {
			background: #1f90f6;
		}

		.controls button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}

		#status {
			font-size: 0.9rem;
			color: #c0c0c0;
			min-width: 8rem;
		}

		.hidden {
			display: none !important;
		}

		#status.status-success {
			color: #4caf50;
		}

		#status.status-error {
			color: #ff6b6b;
		}

		#alert-banner {
			font-size: 0.9rem;
			color: #ff6b6b;
			background: rgba(255, 107, 107, 0.15);
			border: 1px solid rgba(255, 107, 107, 0.4);
			padding: 0.35rem 0.6rem;
			border-radius: 4px;
			display: none;
			max-width: 100%;
		}

		#alert-banner.visible {
			display: inline-flex;
			align-items: center;
		}

		#terminal {
			flex: 1;
			padding: 0.5rem;
		}
	</style>
</head>

<body>
	<div class="controls">
		<form id="connect-form">
			<div class="field" id="namespace-field">
				<span class="field-label">Namespace</span>
				<div class="field-row">
					<input id="namespace-search" class="search-input" type="text" placeholder="Filter namespaces...">
					<select id="namespace" name="namespace"></select>
				</div>
			</div>
			<div class="field" id="vmi-field">
				<span class="field-label">VMI</span>
				<div class="field-row">
					<input id="vmi-search" class="search-input" type="text" placeholder="Filter VMIs...">
					<select id="vmi" name="vmi"></select>
				</div>
			</div>
			<button id="connect-button" type="submit">Connect</button>
		</form>
		<span id="status"></span>
		<span id="alert-banner" role="alert"></span>
	</div>
	<div id="terminal"></div>
	<script src="assets/xterm.min.js"></script>
	<script src="assets/xterm-addon-fit.min.js"></script>
	<script>
		(function () {
			const terminalContainer = document.getElementById('terminal');
			const statusEl = document.getElementById('status');
			const alertBanner = document.getElementById('alert-banner');
			const namespaceField = document.getElementById('namespace-field');
			const vmiField = document.getElementById('vmi-field');
			const namespaceSearch = document.getElementById('namespace-search');
			const vmiSearch = document.getElementById('vmi-search');
			const namespaceSelect = document.getElementById('namespace');
			const vmiSelect = document.getElementById('vmi');
			const connectButton = document.getElementById('connect-button');
			const form = document.getElementById('connect-form');
			const params = new URLSearchParams(window.location.search);
			const initialNamespaceParam = params.get('namespace') || '';
			const initialVMIParam = params.get('vmi') || '';

			const appState = {
				mode: 'shared',
				defaultNamespace: '',
				initialNamespace: '',
				fixedNamespace: '',
				fixedVMI: '',
				namespaceList: [],
				vmiIndex: new Map(),
			};

			const term = new Terminal({
				convertEol: true,
				cursorBlink: true,
				disableStdin: false,
				fontFamily: 'Menlo, Consolas, "Liberation Mono", monospace',
				theme: {
					background: '#1b1b1b'
				}
			});
			const fitAddon = new FitAddon.FitAddon();
			term.loadAddon(fitAddon);
			term.open(terminalContainer);
			fitAddon.fit();
			term.focus();

			let ws = null;
			const decoder = new TextDecoder();

			function updateStatus(text, level, detail) {
				statusEl.textContent = text || '';
				statusEl.classList.remove('status-success', 'status-error');
				if (level === 'success') {
					statusEl.classList.add('status-success');
				} else if (level === 'error') {
					statusEl.classList.add('status-error');
				}
				const detailText = level === 'error' ? (detail ?? text) : '';
				if (level === 'error' && detailText) {
					alertBanner.textContent = detailText;
					alertBanner.classList.add('visible');
				} else if (level !== 'error') {
					alertBanner.textContent = '';
					alertBanner.classList.remove('visible');
				}
			}

			function updateQuery(namespace, vmi) {
				if (appState.mode !== 'shared') {
					return;
				}
				const nextParams = new URLSearchParams();
				if (namespace && namespace !== '__ALL__') {
					nextParams.set('namespace', namespace);
				}
				if (vmi) {
					nextParams.set('vmi', vmi);
				}
				const next = nextParams.toString();
				const nextUrl = `${window.location.pathname}${next ? `?${next}` : ''}`;
				if (nextUrl !== window.location.pathname + window.location.search) {
					history.replaceState(null, '', nextUrl);
				}
			}

			function closeSocket() {
				if (ws) {
					ws.onopen = null;
					ws.onclose = null;
					ws.onerror = null;
					ws.onmessage = null;
					try {
						ws.close();
					} catch (err) {
						console.warn('error closing websocket', err);
					}
					ws = null;
				}
			}

			function optionExists(selectElement, value, namespace) {
				return Array.from(selectElement.options).some(opt => !opt.disabled && opt.value === value && (namespace === undefined || !namespace || opt.dataset.namespace === namespace));
			}

			function renderNamespaceOptions(namespaces, filterText = '', preferredValue) {
				appState.namespaceList = namespaces.slice();
				const previous = (preferredValue !== undefined ? preferredValue : namespaceSelect.value) || '__ALL__';
				const normalized = filterText.trim().toLowerCase();
				const filtered = namespaces.filter(ns => !normalized || ns.toLowerCase().includes(normalized));

				namespaceSelect.textContent = '';
				const options = [{ value: '__ALL__', label: 'All namespaces' }];
				if (filtered.length === 0) {
					options.push({ value: '', label: '-- no namespaces --', disabled: true });
				} else {
					filtered.forEach(ns => options.push({ value: ns, label: ns }));
				}

				options.forEach(opt => {
					const option = document.createElement('option');
					option.value = opt.value;
					option.textContent = opt.label;
					if (opt.disabled) {
						option.disabled = true;
					}
					namespaceSelect.appendChild(option);
				});

				let desired = previous;
				if (!optionExists(namespaceSelect, desired)) {
					desired = filtered.length > 0 ? filtered[0] : '__ALL__';
				}
				namespaceSelect.value = desired;
				return namespaceSelect.value;
			}

			function renderVmiOptions(filterNamespace, searchText = '', preferredValue, preferredNamespace) {
				const previousValue = preferredValue !== undefined ? preferredValue : vmiSelect.value;
				const previousNamespace = preferredNamespace !== undefined ? preferredNamespace : (vmiSelect.options[vmiSelect.selectedIndex] ? vmiSelect.options[vmiSelect.selectedIndex].dataset.namespace : '');

				const normalizedNamespace = filterNamespace && filterNamespace !== '__ALL__' ? filterNamespace : '';
				const normalizedSearch = searchText.trim().toLowerCase();

				let entries = [];
				if (normalizedNamespace && appState.vmiIndex.has(normalizedNamespace)) {
					appState.vmiIndex.get(normalizedNamespace).forEach(name => {
						entries.push({ namespace: normalizedNamespace, name });
					});
				} else {
					appState.vmiIndex.forEach((names, ns) => {
						names.forEach(name => entries.push({ namespace: ns, name }));
					});
				}

				if (normalizedSearch) {
					entries = entries.filter(entry => entry.name.toLowerCase().includes(normalizedSearch) || entry.namespace.toLowerCase().includes(normalizedSearch));
				}

				entries.sort((a, b) => {
					if (a.namespace === b.namespace) {
						return a.name.localeCompare(b.name);
					}
					return a.namespace.localeCompare(b.namespace);
				});

				vmiSelect.textContent = '';
				if (entries.length === 0) {
					const placeholder = document.createElement('option');
					placeholder.value = '';
					placeholder.textContent = '-- no VMIs --';
					placeholder.disabled = true;
					placeholder.selected = true;
					vmiSelect.appendChild(placeholder);
					updateConnectAvailability();
					return null;
				}

				entries.forEach(entry => {
					const option = document.createElement('option');
					option.value = entry.name;
					option.textContent = normalizedNamespace ? entry.name : `${entry.namespace}/${entry.name}`;
					option.dataset.namespace = entry.namespace;
					vmiSelect.appendChild(option);
				});

				let desiredNamespace = previousNamespace;
				let desiredValue = previousValue;
				if (!entries.some(entry => entry.name === desiredValue && (!desiredNamespace || entry.namespace === desiredNamespace))) {
					desiredNamespace = entries[0].namespace;
					desiredValue = entries[0].name;
				}

				const index = entries.findIndex(entry => entry.name === desiredValue && entry.namespace === desiredNamespace);
				vmiSelect.selectedIndex = index >= 0 ? index : 0;
				updateConnectAvailability();
				return vmiSelect.options[vmiSelect.selectedIndex];
			}

			function updateConnectAvailability() {
				const option = vmiSelect.options[vmiSelect.selectedIndex];
				const enabled = !!(option && !option.disabled && option.value);
				connectButton.disabled = !enabled;
			}

			function findNamespaceForVmi(vmiName) {
				for (const [ns, list] of appState.vmiIndex.entries()) {
					if (list.includes(vmiName)) {
						return ns;
					}
				}
				return '';
			}

			function syncQueryFromSelection() {
				if (appState.mode !== 'shared') {
					return;
				}
				const option = vmiSelect.options[vmiSelect.selectedIndex];
				if (!option || option.disabled || !option.value) {
					updateQuery(namespaceSelect.value === '__ALL__' ? '' : namespaceSelect.value, '');
					return;
				}
				const ns = (namespaceSelect.value && namespaceSelect.value !== '__ALL__') ? namespaceSelect.value : (option.dataset.namespace || '');
				updateQuery(ns, option.value);
			}

			function connect(namespace, vmi) {
				const option = vmiSelect.options[vmiSelect.selectedIndex];
				const resolvedVMI = option && !option.disabled ? option.value : (vmi || '').trim();
				if (!resolvedVMI) {
					updateStatus('VMI is required', 'error');
					return;
				}

				let resolvedNamespace = namespace && namespace !== '__ALL__' ? namespace.trim() : '';
				if (!resolvedNamespace && option && option.dataset.namespace) {
					resolvedNamespace = option.dataset.namespace;
				}
				if (appState.mode === 'dedicated') {
					resolvedNamespace = appState.fixedNamespace || appState.defaultNamespace || resolvedNamespace;
				}
				if (!resolvedNamespace) {
					resolvedNamespace = findNamespaceForVmi(resolvedVMI) || appState.initialNamespace || appState.defaultNamespace || '';
				}
				if (!resolvedNamespace) {
					updateStatus('Namespace is required', 'error');
					return;
				}

				closeSocket();
				const loc = window.location;
				const protocol = loc.protocol === 'https:' ? 'wss' : 'ws';
				const wsParams = new URLSearchParams();
				wsParams.set('namespace', resolvedNamespace);
				wsParams.set('vmi', resolvedVMI);
				const endpoint = `${protocol}://${loc.host}/ws?${wsParams.toString()}`;
				const nsLabel = resolvedNamespace ? resolvedNamespace : '(default namespace)';
				console.log('connecting to websocket', endpoint);
				updateStatus(`Connecting to ${nsLabel}/${resolvedVMI} ...`);
				ws = new WebSocket(endpoint);
				ws.binaryType = 'arraybuffer';

				ws.onopen = function () {
					console.log('websocket open');
					term.clear();
					fitAddon.fit();
					updateStatus('Connected', 'success');
					term.focus();
				};

				ws.onmessage = function (event) {
					if (event.data instanceof ArrayBuffer) {
						term.write(decoder.decode(event.data));
					} else if (typeof event.data === 'string') {
						if (event.data === 'serial console ready') {
							updateStatus('Connected', 'success');
						} else if (event.data.startsWith('serial console error:') || event.data.startsWith('console ')) {
							updateStatus('Console error', 'error', event.data);
							term.writeln(`\r\n${event.data}\r\n`);
						} else {
							term.write(event.data);
						}
					}
				};

				ws.onerror = function (event) {
					console.error('websocket error', event);
					updateStatus('Connection error', 'error');
				};

				ws.onclose = function (event) {
					console.log('websocket closed', event);
					const statusText = event.wasClean ? 'Connection closed' : 'Connection lost';
					updateStatus(statusText, event.wasClean ? undefined : 'error');
				};
			}

			function loadVmis() {
				updateStatus('Loading VMIs ...');
				return fetch('/api/vmis')
					.then(response => {
						if (!response.ok) {
							throw new Error(`HTTP ${response.status}`);
						}
						return response.json();
					})
					.then(data => {
						const namespaceSet = new Set();
						const vmiMap = new Map();
						data.forEach(item => {
							const ns = item.namespace || '';
							const name = item.name || '';
							if (!name) {
								return;
							}
							namespaceSet.add(ns);
							if (!vmiMap.has(ns)) {
								vmiMap.set(ns, new Set());
							}
							vmiMap.get(ns).add(name);
						});
						const sortedNamespaces = Array.from(namespaceSet).sort();
						const normalizedMap = new Map();
						vmiMap.forEach((set, ns) => {
							normalizedMap.set(ns, Array.from(set).sort());
						});
						appState.vmiIndex = normalizedMap;
						const selectedNamespace = renderNamespaceOptions(sortedNamespaces, namespaceSearch.value, initialNamespaceParam || appState.initialNamespace || '__ALL__');
						const option = renderVmiOptions(selectedNamespace, vmiSearch.value, initialVMIParam || '', selectedNamespace === '__ALL__' ? '' : selectedNamespace);
						if (initialVMIParam && option && option.value === initialVMIParam) {
							console.log('auto-connecting using URL parameters');
							updateStatus('Preparing connection ...');
							connect(option.dataset.namespace || selectedNamespace, initialVMIParam);
						} else {
							syncQueryFromSelection();
							updateStatus('Ready');
						}
					})
					.catch(err => {
						updateStatus('Failed to load VMIs', 'error', err.message || String(err));
					});
			}

			function initializeDedicatedMode(config) {
				namespaceSearch.classList.add('hidden');
				vmiSearch.classList.add('hidden');
				namespaceSelect.textContent = '';
				vmiSelect.textContent = '';
				namespaceSelect.disabled = true;
				vmiSelect.disabled = true;

				const ns = config.fixedNamespace || config.defaultNamespace || '';
				const nsOption = document.createElement('option');
				nsOption.value = ns;
				nsOption.textContent = ns;
				namespaceSelect.appendChild(nsOption);

				const vmiOption = document.createElement('option');
				vmiOption.value = config.fixedVmi;
				vmiOption.textContent = config.fixedVmi;
				vmiOption.dataset.namespace = ns;
				vmiSelect.appendChild(vmiOption);
				connectButton.disabled = false;
				updateStatus('Preparing connection ...');
				connect(ns, config.fixedVmi);
			}

			function initializeSharedMode() {
				namespaceSearch.classList.remove('hidden');
				vmiSearch.classList.remove('hidden');
				namespaceSelect.disabled = false;
				vmiSelect.disabled = false;
				connectButton.disabled = true;

				namespaceSearch.addEventListener('input', () => {
					const ns = renderNamespaceOptions(appState.namespaceList, namespaceSearch.value, namespaceSelect.value);
					renderVmiOptions(ns, vmiSearch.value, vmiSelect.value, ns === '__ALL__' ? '' : ns);
					syncQueryFromSelection();
				});

				namespaceSelect.addEventListener('change', () => {
					renderVmiOptions(namespaceSelect.value, vmiSearch.value, vmiSelect.value, namespaceSelect.value === '__ALL__' ? '' : namespaceSelect.value);
					syncQueryFromSelection();
				});

				vmiSearch.addEventListener('input', () => {
					renderVmiOptions(namespaceSelect.value, vmiSearch.value, vmiSelect.value, namespaceSelect.value === '__ALL__' ? '' : namespaceSelect.value);
					syncQueryFromSelection();
				});

				vmiSelect.addEventListener('change', () => {
					updateConnectAvailability();
					syncQueryFromSelection();
				});

				loadVmis();
			}

			function initialize() {
				updateStatus('Loading console config ...');
				fetch('/api/config')
					.then(response => {
						if (!response.ok) {
							throw new Error(`HTTP ${response.status}`);
						}
						return response.json();
					})
					.then(config => {
						appState.mode = config.mode || 'shared';
						appState.defaultNamespace = config.defaultNamespace || '';
						appState.initialNamespace = config.initialNamespace || appState.defaultNamespace || '';
						appState.fixedNamespace = config.fixedNamespace || '';
						appState.fixedVMI = config.fixedVmi || '';

						if (appState.mode === 'dedicated') {
							initializeDedicatedMode(config);
						} else {
							initializeSharedMode();
						}
					})
					.catch(err => {
						updateStatus('Failed to load console config', 'error', err.message || String(err));
					});
			}

			form.addEventListener('submit', function (event) {
				event.preventDefault();
				connect(namespaceSelect.value, vmiSelect.value);
			});

			term.onData(function (data) {
				if (ws && ws.readyState === WebSocket.OPEN) {
					ws.send(data);
				}
			});

			window.addEventListener('resize', function () {
				fitAddon.fit();
			});

			initialize();
		})();
	</script>
</body>

</html>
