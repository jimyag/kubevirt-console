<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>KubeVirt VMI Serial Console</title>
	<link rel="stylesheet" href="assets/xterm.min.css">
	<style>
		html,
		body {
			height: 100%;
			margin: 0;
			background: #1b1b1b;
			color: #f5f5f5;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
		}

		body {
			display: flex;
			flex-direction: column;
		}

		.controls {
			display: flex;
			align-items: center;
			gap: 0.75rem;
			padding: 0.75rem 1rem;
			background: #111;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
			z-index: 1;
			flex-wrap: wrap;
		}

		.controls form {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			margin: 0;
			flex-wrap: wrap;
		}

		.controls select,
		.controls input {
			padding: 0.35rem 0.6rem;
			border-radius: 4px;
			border: 1px solid #2f2f2f;
			background: #1f1f1f;
			color: #f5f5f5;
		}

		.controls button {
			padding: 0.35rem 0.9rem;
			border-radius: 4px;
			border: none;
			background: #0078d4;
			color: #fff;
			cursor: pointer;
		}

		.controls button:hover {
			background: #1f90f6;
		}

		#status {
			font-size: 0.9rem;
			color: #c0c0c0;
			min-width: 8rem;
		}

		.hidden {
			display: none !important;
		}

		#status.status-success {
			color: #4caf50;
		}

		#status.status-error {
			color: #ff6b6b;
		}

		#alert-banner {
			font-size: 0.9rem;
			color: #ff6b6b;
			background: rgba(255, 107, 107, 0.15);
			border: 1px solid rgba(255, 107, 107, 0.4);
			padding: 0.35rem 0.6rem;
			border-radius: 4px;
			display: none;
			max-width: 100%;
		}

		#alert-banner.visible {
			display: inline-flex;
			align-items: center;
		}

		#terminal {
			flex: 1;
			padding: 0.5rem;
		}
	</style>
</head>

<body>
	<div class="controls">
		<form id="connect-form">
			<label for="namespace">Namespace</label>
			<select id="namespace" name="namespace"></select>
			<label for="vmi">VMI</label>
			<select id="vmi" name="vmi"></select>
			<button type="submit">Connect</button>
		</form>
		<span id="status"></span>
		<span id="alert-banner" role="alert"></span>
	</div>
	<div id="terminal"></div>
	<script src="assets/xterm.min.js"></script>
	<script src="assets/xterm-addon-fit.min.js"></script>
	<script>
		(function () {
			const terminalContainer = document.getElementById('terminal');
			const statusEl = document.getElementById('status');
			const alertBanner = document.getElementById('alert-banner');
			const namespaceSelect = document.getElementById('namespace');
			const vmiSelect = document.getElementById('vmi');
			const form = document.getElementById('connect-form');
			const params = new URLSearchParams(window.location.search);
			const initialNamespaceParam = params.get('namespace') || '';
			const initialVMIParam = params.get('vmi') || '';

			const appState = {
				mode: 'shared',
				defaultNamespace: '',
				initialNamespace: '',
				fixedNamespace: '',
				fixedVMI: '',
				vmiIndex: new Map(),
			};

			const term = new Terminal({
				convertEol: true,
				cursorBlink: true,
				disableStdin: false,
				fontFamily: 'Menlo, Consolas, "Liberation Mono", monospace',
				theme: {
					background: '#1b1b1b'
				}
			});
			const fitAddon = new FitAddon.FitAddon();
			term.loadAddon(fitAddon);
			term.open(terminalContainer);
			fitAddon.fit();
			term.focus();

			let ws = null;
			const decoder = new TextDecoder();

			function updateStatus(text, level, detail) {
				statusEl.textContent = text || '';
				statusEl.classList.remove('status-success', 'status-error');
				if (level === 'success') {
					statusEl.classList.add('status-success');
				} else if (level === 'error') {
					statusEl.classList.add('status-error');
				}
				const detailText = level === 'error' ? (detail ?? text) : '';
				if (level === 'error' && detailText) {
					alertBanner.textContent = detailText;
					alertBanner.classList.add('visible');
				} else if (level !== 'error') {
					alertBanner.textContent = '';
					alertBanner.classList.remove('visible');
				}
			}

			function updateQuery(namespace, vmi) {
				if (appState.mode !== 'shared') {
					return;
				}
				const nextParams = new URLSearchParams();
				if (namespace) {
					nextParams.set('namespace', namespace);
				}
				if (vmi) {
					nextParams.set('vmi', vmi);
				}
				const next = nextParams.toString();
				const nextUrl = `${window.location.pathname}${next ? `?${next}` : ''}`;
				if (nextUrl !== window.location.pathname + window.location.search) {
					history.replaceState(null, '', nextUrl);
				}
			}

			function closeSocket() {
				if (ws) {
					ws.onopen = null;
					ws.onclose = null;
					ws.onerror = null;
					ws.onmessage = null;
					try {
						ws.close();
					} catch (err) {
						console.warn('error closing websocket', err);
					}
					ws = null;
				}
			}

			function renderNamespaceOptions(namespaces) {
				namespaceSelect.textContent = '';
				namespaces.forEach(ns => {
					const option = document.createElement('option');
					option.value = ns;
					option.textContent = ns;
					namespaceSelect.appendChild(option);
				});
			}

			function renderVmiOptions(filterNamespace) {
				vmiSelect.textContent = '';
				const entries = [];
				if (filterNamespace && appState.vmiIndex.has(filterNamespace)) {
					appState.vmiIndex.get(filterNamespace).forEach(name => {
						entries.push({ namespace: filterNamespace, name });
					});
				} else {
					appState.vmiIndex.forEach((names, ns) => {
						names.forEach(name => entries.push({ namespace: ns, name }));
					});
				}
				entries.sort((a, b) => {
					if (a.namespace === b.namespace) {
						return a.name.localeCompare(b.name);
					}
					return a.namespace.localeCompare(b.namespace);
				});
				entries.forEach(entry => {
					const option = document.createElement('option');
					option.value = entry.name;
					option.textContent = `${entry.namespace}/${entry.name}`;
					option.dataset.namespace = entry.namespace;
					vmiSelect.appendChild(option);
				});
			}

			function findNamespaceForVmi(vmiName) {
				const options = vmiSelect.options;
				for (let i = 0; i < options.length; i++) {
					if (options[i].value === vmiName) {
						return options[i].dataset.namespace || '';
					}
				}
				return '';
			}

			function connect(namespace, vmi) {
				const selectedOption = vmiSelect.options[vmiSelect.selectedIndex];
				const resolvedVMI = selectedOption ? selectedOption.value : (vmi || '').trim();
				if (!resolvedVMI) {
					updateStatus('VMI is required', 'error');
					return;
				}
				let resolvedNamespace = namespace ? namespace.trim() : '';
				if (appState.mode === 'dedicated') {
					resolvedNamespace = appState.fixedNamespace || appState.defaultNamespace || resolvedNamespace;
				} else {
					if (!resolvedNamespace) {
						const nsOption = namespaceSelect.options[namespaceSelect.selectedIndex];
						if (nsOption) {
							resolvedNamespace = nsOption.value;
						}
					}
					if (!resolvedNamespace) {
						resolvedNamespace = findNamespaceForVmi(resolvedVMI) || appState.initialNamespace || appState.defaultNamespace || '';
					}
				}
				if (!resolvedNamespace) {
					updateStatus('Namespace is required', 'error');
					return;
				}

				closeSocket();
				const loc = window.location;
				const protocol = loc.protocol === 'https:' ? 'wss' : 'ws';
				const wsParams = new URLSearchParams();
				wsParams.set('namespace', resolvedNamespace);
				wsParams.set('vmi', resolvedVMI);
				const endpoint = `${protocol}://${loc.host}/ws?${wsParams.toString()}`;
				const nsLabel = resolvedNamespace ? resolvedNamespace : '(default namespace)';
				if (appState.mode === 'shared') {
					updateQuery(resolvedNamespace, resolvedVMI);
				}
				console.log('connecting to websocket', endpoint);
				updateStatus(`Connecting to ${nsLabel}/${resolvedVMI} ...`);
				ws = new WebSocket(endpoint);
				ws.binaryType = 'arraybuffer';

				ws.onopen = function () {
					console.log('websocket open');
					term.clear();
					fitAddon.fit();
					updateStatus('Connected', 'success');
					term.focus();
				};

				ws.onmessage = function (event) {
					if (event.data instanceof ArrayBuffer) {
						term.write(decoder.decode(event.data));
					} else if (typeof event.data === 'string') {
						if (event.data === 'serial console ready') {
							updateStatus('Connected', 'success');
						} else if (event.data.startsWith('serial console error:') || event.data.startsWith('console ')) {
							updateStatus('Console error', 'error', event.data);
							term.writeln(`\r\n${event.data}\r\n`);
						} else {
							term.write(event.data);
						}
					}
				};

				ws.onerror = function (event) {
					console.error('websocket error', event);
					updateStatus('Connection error', 'error');
				};

				ws.onclose = function (event) {
					console.log('websocket closed', event);
					const statusText = event.wasClean ? 'Connection closed' : 'Connection lost';
					updateStatus(statusText, event.wasClean ? undefined : 'error');
				};
			}

			function loadVmis() {
				updateStatus('Loading VMIs ...');
				return fetch('/api/vmis')
					.then(response => {
						if (!response.ok) {
							throw new Error(`HTTP ${response.status}`);
						}
						return response.json();
					})
					.then(data => {
						const namespaceSet = new Set();
						const vmiMap = new Map();
						data.forEach(item => {
							const ns = item.namespace || '';
							const name = item.name || '';
							if (!name) {
								return;
							}
							namespaceSet.add(ns);
							if (!vmiMap.has(ns)) {
								vmiMap.set(ns, new Set());
							}
							vmiMap.get(ns).add(name);
						});
						appState.vmiIndex = vmiMap;
						const sortedNamespaces = Array.from(namespaceSet).sort();
						renderNamespaceOptions(sortedNamespaces);
						let nsValue = namespaceSelect.value;
						if (appState.mode === 'shared') {
							if (!nsValue || !namespaceSet.has(nsValue)) {
								nsValue = initialNamespaceParam || appState.initialNamespace || sortedNamespaces[0] || '';
								namespaceSelect.value = nsValue;
							}
							renderVmiOptions(nsValue);
							if (initialVMIParam && vmiSelect.querySelector(`option[value="${initialVMIParam}"]`)) {
								vmiSelect.value = initialVMIParam;
							}
						}
						updateStatus('Ready');
					})
					.catch(err => {
						updateStatus('Failed to load VMIs', 'error', err.message || String(err));
					});
			}

			function initializeDedicatedMode(config) {
				const ns = config.fixedNamespace || config.defaultNamespace || '';
				namespaceSelect.innerHTML = '';
				const nsOption = document.createElement('option');
				nsOption.value = ns;
				nsOption.textContent = ns;
				namespaceSelect.appendChild(nsOption);
				namespaceSelect.disabled = true;

				vmiSelect.innerHTML = '';
				const vmiOption = document.createElement('option');
				vmiOption.value = config.fixedVmi;
				vmiOption.textContent = config.fixedVmi;
				vmiOption.dataset.namespace = ns;
				vmiSelect.appendChild(vmiOption);
				vmiSelect.disabled = true;

				form.classList.add('hidden');
				updateStatus('Preparing connection ...');
				connect(ns, config.fixedVmi);
			}

			function initializeSharedMode(config) {
				form.classList.remove('hidden');
				namespaceSelect.disabled = false;
				vmiSelect.disabled = false;
				namespaceSelect.addEventListener('change', () => {
					renderVmiOptions(namespaceSelect.value);
					if (appState.mode === 'shared') {
						updateQuery(namespaceSelect.value, vmiSelect.value);
					}
				});
				vmiSelect.addEventListener('change', () => {
					if (appState.mode === 'shared') {
						updateQuery(namespaceSelect.value, vmiSelect.value);
					}
				});
				loadVmis().then(() => {
					if (initialNamespaceParam) {
						namespaceSelect.value = initialNamespaceParam;
						renderVmiOptions(initialNamespaceParam);
					}
					if (initialVMIParam && vmiSelect.querySelector(`option[value="${initialVMIParam}"]`)) {
						vmiSelect.value = initialVMIParam;
					}
					if (initialVMIParam) {
						console.log('auto-connecting using URL parameters');
						updateStatus('Preparing connection ...');
						connect(namespaceSelect.value, initialVMIParam);
					}
				});
			}

			function initialize() {
				fetch('/api/config')
					.then(response => {
						if (!response.ok) {
							throw new Error(`HTTP ${response.status}`);
						}
						return response.json();
					})
					.then(config => {
						appState.mode = config.mode || 'shared';
						appState.defaultNamespace = config.defaultNamespace || '';
						appState.initialNamespace = config.initialNamespace || appState.defaultNamespace || '';
						appState.fixedNamespace = config.fixedNamespace || '';
						appState.fixedVMI = config.fixedVmi || '';

						if (appState.mode === 'dedicated') {
							initializeDedicatedMode(config);
						} else {
							initializeSharedMode(config);
						}
					})
					.catch(err => {
						updateStatus('Failed to load console config', 'error', err.message || String(err));
					});
			}

			form.addEventListener('submit', function (event) {
				event.preventDefault();
				connect(namespaceSelect.value, vmiSelect.value);
			});

			term.onData(function (data) {
				if (ws && ws.readyState === WebSocket.OPEN) {
					ws.send(data);
				}
			});

			window.addEventListener('resize', function () {
				fitAddon.fit();
			});

			initialize();
		})();
	</script>
</body>

</html>
